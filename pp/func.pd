# TODO core function, after F<primitive.pd>
#pp_def( 'hash_with',
#	Pars => 'a(); int [o] b()',
#	Code => '',
#);

# auxiliary routine for setting empty bins to bad
pp_def( '_setnulltobad',
	Pars => 'count(n); [o] out(n)',
	HandleBad => 1,
	Code => '
		int flag = 0;
		loop(n) %{
			if( ! $count() ) { $SETBAD(out()); flag = 1; }
		%}
		if( flag ) { $PDLSTATESETBAD(out); }
	',
	BadCode => '
		int flag = 0;
		loop(n) %{
			if( ! $count() ) { $SETBAD(out()); flag = 1; }
		%}
		if( flag ) { $PDLSTATESETBAD(out); }
	',
);

# indirect count
# assumes that the indices are always valid (no bad values)
# icount always returns a piddle of type int
pp_def( '_icount_loop',
	Pars => 'in(n); int ind(n); int [o] out(m)',
	OtherPars => 'int msize => m',
	HandleBad => 1,
	Code => '
		loop(n) %{
			register int j = $ind();
			++( $out(m => j) );
		%}
	',
	BadCode => '
		loop(n) %{
			register int j = $ind();
			if( $ISGOOD( in() ) ) { ++( $out(m => j) ); }
		%}
	',
);

# indirect sum
# assumes that the indices are always valid (no bad values)
# isum returns a piddle of type int, or higher, to reduce the risk of overflow
# when collecting sums
pp_def( '_isum_loop',
	Pars => 'in(n); int ind(n); int+ [o] out(m); int [t] count(m)',
	OtherPars => 'int msize => m',
	HandleBad => 1,
	Code => '
		loop(n) %{
			register int j = $ind();
			$out(m => j) += $in();
			++( $count(m => j) );
		%}
	',
	BadCode => '
		loop(n) %{
			register int j = $ind();
			if( $ISGOOD( in() ) ) {
				$out(m => j) += $in();
				++( $count(m => j) );
			}
		%}
	',
);

# indirect average, solid implementation
pp_def( '_iavg_loop',
	Pars => 'in(n); int ind(n); double [o] out(m); int [t] count(m)',
	OtherPars => 'int msize => m',
	HandleBad => 1,
	Code => '
		loop(n) %{
			register int j = $ind();
			$out(m => j) += ( $in() - $out(m => j) ) / ++( $count(m => j) );
		%}
	',
	BadCode => '
		loop(n) %{
			register int j = $ind();
			if( $ISGOOD( in() ) ) {
				$out(m => j) += ( $in() - $out(m => j) ) / ++( $count(m => j) );
			}
		%}
	',
);

# indirect standard deviation
pp_def ( '_istddev_loop',
	Pars => 'in(n); int ind(n); double [o] out(m); int [t] count(m); double [t] avg(m)',
	OtherPars => 'int msize => m',
	HandleBad => 1,
	Code => '
		loop(n) %{
			register int j = $ind();
			double delta = $in() - $avg(m => j);
			$avg(m => j) += delta / ++( $count(m => j) );
			$out(m => j) += delta * ( $in() - $avg(m => j) );
		%}
	',
	BadCode => '
		loop(n) %{
			register int j = $ind();
			double delta;
			if( $ISGOOD( in() ) ) {
				delta = $in() - $avg(m => j);
				$avg(m => j) += delta / ++( $count(m => j) );
				$out(m => j) += delta * ( $in() - $avg(m => j) );
			}
		%}
	',
);

# finalization for _istddev_loop()
pp_def( '_istddev_post',
	Pars => 'count(n); [o] out(n)',
	HandleBad => 1,
	Code => '
		int flag = 0;
		loop(n) %{
			if( ! $count() ) { $SETBAD(out()); flag = 1; }
			else { $out() = sqrt( $out() / $count() ); }
		%}
		if( flag ) { $PDLSTATESETBAD(out); }
	',
	BadCode => '
		int flag = 0;
		loop(n) %{
			if( ! $count() ) { $SETBAD(out()); flag = 1; }
			else { $out() = sqrt( $out() / $count() ); }
		%}
		if( flag ) { $PDLSTATESETBAD(out); }
	',
);

# TODO
# complete with the other functions that xyz2grd provides
# indirect maximum
# indirect minimum

# vim:set filetype=perl:
